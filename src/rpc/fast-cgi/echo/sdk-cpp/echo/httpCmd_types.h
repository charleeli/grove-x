/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef httpCmd_TYPES_H
#define httpCmd_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace HttpCmd {

struct STATUS {
  enum type {
    SUCCESS = 0,
    FAILED = -1,
    EXCEPTION = -2,
    NO_COMMAND = -3,
    PARSE_FAIL = -4,
    CHECK_FAIL = -5
  };
};

extern const std::map<int, const char*> _STATUS_VALUES_TO_NAMES;

class Header;

class HttpRequest;

class HttpResponse;


class Header {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Header(const Header&);
  Header& operator=(const Header&);
  Header() {
  }

  virtual ~Header() throw();

  bool operator == (const Header & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Header& obj);
};

void swap(Header &a, Header &b);


class HttpRequest {
 public:

  static const char* ascii_fingerprint; // = "CD8BE83E651738586A465FCAD3542247";
  static const uint8_t binary_fingerprint[16]; // = {0xCD,0x8B,0xE8,0x3E,0x65,0x17,0x38,0x58,0x6A,0x46,0x5F,0xCA,0xD3,0x54,0x22,0x47};

  HttpRequest(const HttpRequest&);
  HttpRequest& operator=(const HttpRequest&);
  HttpRequest() : command() {
  }

  virtual ~HttpRequest() throw();
  std::string command;
  Header header;

  void __set_command(const std::string& val);

  void __set_header(const Header& val);

  bool operator == (const HttpRequest & rhs) const
  {
    if (!(command == rhs.command))
      return false;
    if (!(header == rhs.header))
      return false;
    return true;
  }
  bool operator != (const HttpRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HttpRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HttpRequest& obj);
};

void swap(HttpRequest &a, HttpRequest &b);


class HttpResponse {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  HttpResponse(const HttpResponse&);
  HttpResponse& operator=(const HttpResponse&);
  HttpResponse() : error(0), errmsg() {
  }

  virtual ~HttpResponse() throw();
  int32_t error;
  std::string errmsg;

  void __set_error(const int32_t val);

  void __set_errmsg(const std::string& val);

  bool operator == (const HttpResponse & rhs) const
  {
    if (!(error == rhs.error))
      return false;
    if (!(errmsg == rhs.errmsg))
      return false;
    return true;
  }
  bool operator != (const HttpResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HttpResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HttpResponse& obj);
};

void swap(HttpResponse &a, HttpResponse &b);

} // namespace

#endif
