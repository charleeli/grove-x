// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef ONSALE_ODB_HXX
#define ONSALE_ODB_HXX

// Begin prologue.
//
#include <odb/boost/version.hxx>
#if ODB_BOOST_VERSION != 2040000 // 2.4.0
#  error ODB and C++ compilers see different libodb-boost interface versions
#endif
#include <boost/shared_ptr.hpp>
#include <odb/boost/smart-ptr/pointer-traits.hxx>
#include <odb/boost/smart-ptr/wrapper-traits.hxx>
#include <odb/boost/optional/wrapper-traits.hxx>
#include <odb/boost/unordered/container-traits.hxx>
#include <odb/boost/date-time/mysql/gregorian-traits.hxx>
#include <odb/boost/date-time/mysql/posix-time-traits.hxx>
#include <odb/boost/multi-index/container-traits.hxx>
#include <odb/boost/uuid/mysql/uuid-traits.hxx>
//
// End prologue.

#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "onsale.hxx"

#include <memory>
#include <cstddef>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#ifdef BOOST_TR1_MEMORY_HPP_INCLUDED
#  include <odb/tr1/wrapper-traits.hxx>
#  include <odb/tr1/pointer-traits.hxx>
#endif
#include <odb/container-traits.hxx>
#include <odb/session.hxx>
#include <odb/cache-traits.hxx>
#include <odb/prepared-query.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>
#include <odb/no-id-object-result.hxx>
#include <odb/view-image.hxx>
#include <odb/view-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // onsale_warelabel
  //
  template <>
  struct class_traits< ::onsale_warelabel >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::onsale_warelabel >
  {
    public:
    typedef ::onsale_warelabel object_type;
    typedef ::boost::shared_ptr< ::onsale_warelabel > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // onsale_warelabel_stat
  //
  template <>
  struct class_traits< ::onsale_warelabel_stat >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::onsale_warelabel_stat >
  {
    public:
    typedef ::onsale_warelabel_stat view_type;
    typedef ::boost::shared_ptr< ::onsale_warelabel_stat > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // onsale_warelabelwares
  //
  template <>
  struct class_traits< ::onsale_warelabelwares >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::onsale_warelabelwares >
  {
    public:
    typedef ::onsale_warelabelwares object_type;
    typedef ::boost::shared_ptr< ::onsale_warelabelwares > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef void id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_id_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_id_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // onsale_warelabelwares_stat
  //
  template <>
  struct class_traits< ::onsale_warelabelwares_stat >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::onsale_warelabelwares_stat >
  {
    public:
    typedef ::onsale_warelabelwares_stat view_type;
    typedef ::boost::shared_ptr< ::onsale_warelabelwares_stat > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // onsale_present
  //
  template <>
  struct class_traits< ::onsale_present >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::onsale_present >
  {
    public:
    typedef ::onsale_present object_type;
    typedef ::boost::shared_ptr< ::onsale_present > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef void id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_id_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_id_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // onsale_present_stat
  //
  template <>
  struct class_traits< ::onsale_present_stat >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::onsale_present_stat >
  {
    public:
    typedef ::onsale_present_stat view_type;
    typedef ::boost::shared_ptr< ::onsale_present_stat > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // onsale_step
  //
  template <>
  struct class_traits< ::onsale_step >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::onsale_step >
  {
    public:
    typedef ::onsale_step object_type;
    typedef ::boost::shared_ptr< ::onsale_step > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // onsale_step_stat
  //
  template <>
  struct class_traits< ::onsale_step_stat >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::onsale_step_stat >
  {
    public:
    typedef ::onsale_step_stat view_type;
    typedef ::boost::shared_ptr< ::onsale_step_stat > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // onsale_onsalegroup
  //
  template <>
  struct class_traits< ::onsale_onsalegroup >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::onsale_onsalegroup >
  {
    public:
    typedef ::onsale_onsalegroup object_type;
    typedef ::boost::shared_ptr< ::onsale_onsalegroup > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // onsale_onsalegroup_stat
  //
  template <>
  struct class_traits< ::onsale_onsalegroup_stat >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::onsale_onsalegroup_stat >
  {
    public:
    typedef ::onsale_onsalegroup_stat view_type;
    typedef ::boost::shared_ptr< ::onsale_onsalegroup_stat > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };
}

#include <odb/details/buffer.hxx>

#include <odb/mysql/version.hxx>
#include <odb/mysql/forward.hxx>
#include <odb/mysql/binding.hxx>
#include <odb/mysql/mysql-types.hxx>
#include <odb/mysql/query.hxx>

namespace odb
{
  // onsale_warelabel
  //
  template <typename A>
  struct query_columns< ::onsale_warelabel, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // name
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    name_type_;

    static const name_type_ name;

    // label_type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    label_type_type_;

    static const label_type_type_ label_type;

    // scope_type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    scope_type_type_;

    static const scope_type_type_ scope_type;

    // sub_type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    sub_type_type_;

    static const sub_type_type_ sub_type;

    // seller_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::int64_t,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    seller_id_type_;

    static const seller_id_type_ seller_id;

    // seller_slug
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    seller_slug_type_;

    static const seller_slug_type_ seller_slug;

    // create_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    create_time_type_;

    static const create_time_type_ create_time;

    // update_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    update_time_type_;

    static const update_time_type_ update_time;

    // create_man
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    create_man_type_;

    static const create_man_type_ create_man;
  };

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::id_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::name_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  name (A::table_name, "`name`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::label_type_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  label_type (A::table_name, "`label_type`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::scope_type_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  scope_type (A::table_name, "`scope_type`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::sub_type_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  sub_type (A::table_name, "`sub_type`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::seller_id_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  seller_id (A::table_name, "`seller_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::seller_slug_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  seller_slug (A::table_name, "`seller_slug`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::create_time_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  create_time (A::table_name, "`create_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::update_time_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  update_time (A::table_name, "`update_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabel, id_mysql, A >::create_man_type_
  query_columns< ::onsale_warelabel, id_mysql, A >::
  create_man (A::table_name, "`create_man`", 0);

  template <typename A>
  struct pointer_query_columns< ::onsale_warelabel, id_mysql, A >:
    query_columns< ::onsale_warelabel, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::onsale_warelabel, id_mysql >:
    public access::object_traits< ::onsale_warelabel >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      unsigned long long id_value;
      my_bool id_null;

      // name
      //
      details::buffer name_value;
      unsigned long name_size;
      my_bool name_null;

      // label_type
      //
      int label_type_value;
      my_bool label_type_null;

      // scope_type
      //
      int scope_type_value;
      my_bool scope_type_null;

      // sub_type
      //
      int sub_type_value;
      my_bool sub_type_null;

      // seller_id
      //
      long long seller_id_value;
      my_bool seller_id_null;

      // seller_slug
      //
      details::buffer seller_slug_value;
      unsigned long seller_slug_size;
      my_bool seller_slug_null;

      // create_time
      //
      MYSQL_TIME create_time_value;
      my_bool create_time_null;

      // update_time
      //
      MYSQL_TIME update_time_value;
      my_bool update_time_null;

      // create_man
      //
      details::buffer create_man_value;
      unsigned long create_man_size;
      my_bool create_man_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 10UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::onsale_warelabel, id_common >:
    public access::object_traits_impl< ::onsale_warelabel, id_mysql >
  {
  };

  // onsale_warelabel_stat
  //
  template <>
  class access::view_traits_impl< ::onsale_warelabel_stat, id_mysql >:
    public access::view_traits< ::onsale_warelabel_stat >
  {
    public:
    struct image_type
    {
      // count
      //
      unsigned long long count_value;
      my_bool count_null;

      // max_id
      //
      unsigned int max_id_value;
      my_bool max_id_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 2UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  template <>
  class access::view_traits_impl< ::onsale_warelabel_stat, id_common >:
    public access::view_traits_impl< ::onsale_warelabel_stat, id_mysql >
  {
  };

  // onsale_warelabelwares
  //
  template <typename A>
  struct query_columns< ::onsale_warelabelwares, id_mysql, A >
  {
    // ware_label_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    ware_label_id_type_;

    static const ware_label_id_type_ ware_label_id;

    // ware_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::int64_t,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    ware_id_type_;

    static const ware_id_type_ ware_id;

    // create_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    create_time_type_;

    static const create_time_type_ create_time;
  };

  template <typename A>
  const typename query_columns< ::onsale_warelabelwares, id_mysql, A >::ware_label_id_type_
  query_columns< ::onsale_warelabelwares, id_mysql, A >::
  ware_label_id (A::table_name, "`ware_label_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabelwares, id_mysql, A >::ware_id_type_
  query_columns< ::onsale_warelabelwares, id_mysql, A >::
  ware_id (A::table_name, "`ware_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_warelabelwares, id_mysql, A >::create_time_type_
  query_columns< ::onsale_warelabelwares, id_mysql, A >::
  create_time (A::table_name, "`create_time`", 0);

  template <typename A>
  struct pointer_query_columns< ::onsale_warelabelwares, id_mysql, A >:
    query_columns< ::onsale_warelabelwares, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::onsale_warelabelwares, id_mysql >:
    public access::object_traits< ::onsale_warelabelwares >
  {
    public:
    struct image_type
    {
      // ware_label_id
      //
      unsigned int ware_label_id_value;
      my_bool ware_label_id_null;

      // ware_id
      //
      long long ware_id_value;
      my_bool ware_id_null;

      // create_time
      //
      MYSQL_TIME create_time_value;
      my_bool create_time_null;

      std::size_t version;
    };

    using object_traits<object_type>::id;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    typedef mysql::no_id_object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 3UL;
    static const std::size_t id_column_count = 0UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    public:
  };

  template <>
  class access::object_traits_impl< ::onsale_warelabelwares, id_common >:
    public access::object_traits_impl< ::onsale_warelabelwares, id_mysql >
  {
  };

  // onsale_warelabelwares_stat
  //
  template <>
  class access::view_traits_impl< ::onsale_warelabelwares_stat, id_mysql >:
    public access::view_traits< ::onsale_warelabelwares_stat >
  {
    public:
    struct image_type
    {
      // count
      //
      unsigned long long count_value;
      my_bool count_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 1UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  template <>
  class access::view_traits_impl< ::onsale_warelabelwares_stat, id_common >:
    public access::view_traits_impl< ::onsale_warelabelwares_stat, id_mysql >
  {
  };

  // onsale_present
  //
  template <typename A>
  struct query_columns< ::onsale_present, id_mysql, A >
  {
    // step_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    step_id_type_;

    static const step_id_type_ step_id;

    // sku_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::int64_t,
        mysql::id_longlong >::query_type,
      mysql::id_longlong >
    sku_id_type_;

    static const sku_id_type_ sku_id;

    // sku_price
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    sku_price_type_;

    static const sku_price_type_ sku_price;

    // sku_count
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    sku_count_type_;

    static const sku_count_type_ sku_count;

    // sku_slug
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    sku_slug_type_;

    static const sku_slug_type_ sku_slug;
  };

  template <typename A>
  const typename query_columns< ::onsale_present, id_mysql, A >::step_id_type_
  query_columns< ::onsale_present, id_mysql, A >::
  step_id (A::table_name, "`step_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_present, id_mysql, A >::sku_id_type_
  query_columns< ::onsale_present, id_mysql, A >::
  sku_id (A::table_name, "`sku_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_present, id_mysql, A >::sku_price_type_
  query_columns< ::onsale_present, id_mysql, A >::
  sku_price (A::table_name, "`sku_price`", 0);

  template <typename A>
  const typename query_columns< ::onsale_present, id_mysql, A >::sku_count_type_
  query_columns< ::onsale_present, id_mysql, A >::
  sku_count (A::table_name, "`sku_count`", 0);

  template <typename A>
  const typename query_columns< ::onsale_present, id_mysql, A >::sku_slug_type_
  query_columns< ::onsale_present, id_mysql, A >::
  sku_slug (A::table_name, "`sku_slug`", 0);

  template <typename A>
  struct pointer_query_columns< ::onsale_present, id_mysql, A >:
    query_columns< ::onsale_present, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::onsale_present, id_mysql >:
    public access::object_traits< ::onsale_present >
  {
    public:
    struct image_type
    {
      // step_id
      //
      unsigned int step_id_value;
      my_bool step_id_null;

      // sku_id
      //
      long long sku_id_value;
      my_bool sku_id_null;

      // sku_price
      //
      double sku_price_value;
      my_bool sku_price_null;

      // sku_count
      //
      unsigned int sku_count_value;
      my_bool sku_count_null;

      // sku_slug
      //
      details::buffer sku_slug_value;
      unsigned long sku_slug_size;
      my_bool sku_slug_null;

      std::size_t version;
    };

    using object_traits<object_type>::id;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    typedef mysql::no_id_object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 5UL;
    static const std::size_t id_column_count = 0UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    public:
  };

  template <>
  class access::object_traits_impl< ::onsale_present, id_common >:
    public access::object_traits_impl< ::onsale_present, id_mysql >
  {
  };

  // onsale_present_stat
  //
  template <>
  class access::view_traits_impl< ::onsale_present_stat, id_mysql >:
    public access::view_traits< ::onsale_present_stat >
  {
    public:
    struct image_type
    {
      // count
      //
      unsigned long long count_value;
      my_bool count_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 1UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  template <>
  class access::view_traits_impl< ::onsale_present_stat, id_common >:
    public access::view_traits_impl< ::onsale_present_stat, id_mysql >
  {
  };

  // onsale_step
  //
  template <typename A>
  struct query_columns< ::onsale_step, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // onsale_group_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    onsale_group_id_type_;

    static const onsale_group_id_type_ onsale_group_id;

    // full_credit
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    full_credit_type_;

    static const full_credit_type_ full_credit;

    // favor_credit
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    favor_credit_type_;

    static const favor_credit_type_ favor_credit;

    // favor_rate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    favor_rate_type_;

    static const favor_rate_type_ favor_rate;

    // full_count
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    full_count_type_;

    static const full_count_type_ full_count;

    // full_rate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    full_rate_type_;

    static const full_rate_type_ full_rate;

    // full_price
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        double,
        mysql::id_double >::query_type,
      mysql::id_double >
    full_price_type_;

    static const full_price_type_ full_price;
  };

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::id_type_
  query_columns< ::onsale_step, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::onsale_group_id_type_
  query_columns< ::onsale_step, id_mysql, A >::
  onsale_group_id (A::table_name, "`onsale_group_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::full_credit_type_
  query_columns< ::onsale_step, id_mysql, A >::
  full_credit (A::table_name, "`full_credit`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::favor_credit_type_
  query_columns< ::onsale_step, id_mysql, A >::
  favor_credit (A::table_name, "`favor_credit`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::favor_rate_type_
  query_columns< ::onsale_step, id_mysql, A >::
  favor_rate (A::table_name, "`favor_rate`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::full_count_type_
  query_columns< ::onsale_step, id_mysql, A >::
  full_count (A::table_name, "`full_count`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::full_rate_type_
  query_columns< ::onsale_step, id_mysql, A >::
  full_rate (A::table_name, "`full_rate`", 0);

  template <typename A>
  const typename query_columns< ::onsale_step, id_mysql, A >::full_price_type_
  query_columns< ::onsale_step, id_mysql, A >::
  full_price (A::table_name, "`full_price`", 0);

  template <typename A>
  struct pointer_query_columns< ::onsale_step, id_mysql, A >:
    query_columns< ::onsale_step, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::onsale_step, id_mysql >:
    public access::object_traits< ::onsale_step >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      unsigned long long id_value;
      my_bool id_null;

      // onsale_group_id
      //
      unsigned int onsale_group_id_value;
      my_bool onsale_group_id_null;

      // full_credit
      //
      double full_credit_value;
      my_bool full_credit_null;

      // favor_credit
      //
      double favor_credit_value;
      my_bool favor_credit_null;

      // favor_rate
      //
      double favor_rate_value;
      my_bool favor_rate_null;

      // full_count
      //
      unsigned int full_count_value;
      my_bool full_count_null;

      // full_rate
      //
      double full_rate_value;
      my_bool full_rate_null;

      // full_price
      //
      double full_price_value;
      my_bool full_price_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::onsale_step, id_common >:
    public access::object_traits_impl< ::onsale_step, id_mysql >
  {
  };

  // onsale_step_stat
  //
  template <>
  class access::view_traits_impl< ::onsale_step_stat, id_mysql >:
    public access::view_traits< ::onsale_step_stat >
  {
    public:
    struct image_type
    {
      // count
      //
      unsigned long long count_value;
      my_bool count_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 1UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  template <>
  class access::view_traits_impl< ::onsale_step_stat, id_common >:
    public access::view_traits_impl< ::onsale_step_stat, id_mysql >
  {
  };

  // onsale_onsalegroup
  //
  template <typename A>
  struct query_columns< ::onsale_onsalegroup, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // slug
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    slug_type_;

    static const slug_type_ slug;

    // name
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    name_type_;

    static const name_type_ name;

    // title
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    title_type_;

    static const title_type_ title;

    // comment
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    comment_type_;

    static const comment_type_ comment;

    // favor_type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    favor_type_type_;

    static const favor_type_type_ favor_type;

    // label_type
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    label_type_type_;

    static const label_type_type_ label_type;

    // ware_label_id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    ware_label_id_type_;

    static const ware_label_id_type_ ware_label_id;

    // involve_count
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    involve_count_type_;

    static const involve_count_type_ involve_count;

    // start_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    start_time_type_;

    static const start_time_type_ start_time;

    // end_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    end_time_type_;

    static const end_time_type_ end_time;

    // create_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    create_time_type_;

    static const create_time_type_ create_time;

    // update_time
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    update_time_type_;

    static const update_time_type_ update_time;

    // verify_status
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    verify_status_type_;

    static const verify_status_type_ verify_status;

    // applicant
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    applicant_type_;

    static const applicant_type_ applicant;

    // approver
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    approver_type_;

    static const approver_type_ approver;

    // modifier
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    modifier_type_;

    static const modifier_type_ modifier;

    // jump_label
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    jump_label_type_;

    static const jump_label_type_ jump_label;

    // jump_data
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    jump_data_type_;

    static const jump_data_type_ jump_data;
  };

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::id_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::slug_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  slug (A::table_name, "`slug`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::name_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  name (A::table_name, "`name`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::title_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  title (A::table_name, "`title`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::comment_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  comment (A::table_name, "`comment`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::favor_type_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  favor_type (A::table_name, "`favor_type`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::label_type_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  label_type (A::table_name, "`label_type`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::ware_label_id_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  ware_label_id (A::table_name, "`ware_label_id`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::involve_count_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  involve_count (A::table_name, "`involve_count`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::start_time_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  start_time (A::table_name, "`start_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::end_time_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  end_time (A::table_name, "`end_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::create_time_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  create_time (A::table_name, "`create_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::update_time_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  update_time (A::table_name, "`update_time`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::verify_status_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  verify_status (A::table_name, "`verify_status`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::applicant_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  applicant (A::table_name, "`applicant`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::approver_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  approver (A::table_name, "`approver`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::modifier_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  modifier (A::table_name, "`modifier`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::jump_label_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  jump_label (A::table_name, "`jump_label`", 0);

  template <typename A>
  const typename query_columns< ::onsale_onsalegroup, id_mysql, A >::jump_data_type_
  query_columns< ::onsale_onsalegroup, id_mysql, A >::
  jump_data (A::table_name, "`jump_data`", 0);

  template <typename A>
  struct pointer_query_columns< ::onsale_onsalegroup, id_mysql, A >:
    query_columns< ::onsale_onsalegroup, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::onsale_onsalegroup, id_mysql >:
    public access::object_traits< ::onsale_onsalegroup >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id
      //
      unsigned long long id_value;
      my_bool id_null;

      // slug
      //
      details::buffer slug_value;
      unsigned long slug_size;
      my_bool slug_null;

      // name
      //
      details::buffer name_value;
      unsigned long name_size;
      my_bool name_null;

      // title
      //
      details::buffer title_value;
      unsigned long title_size;
      my_bool title_null;

      // comment
      //
      details::buffer comment_value;
      unsigned long comment_size;
      my_bool comment_null;

      // favor_type
      //
      int favor_type_value;
      my_bool favor_type_null;

      // label_type
      //
      int label_type_value;
      my_bool label_type_null;

      // ware_label_id
      //
      int ware_label_id_value;
      my_bool ware_label_id_null;

      // involve_count
      //
      int involve_count_value;
      my_bool involve_count_null;

      // start_time
      //
      MYSQL_TIME start_time_value;
      my_bool start_time_null;

      // end_time
      //
      MYSQL_TIME end_time_value;
      my_bool end_time_null;

      // create_time
      //
      MYSQL_TIME create_time_value;
      my_bool create_time_null;

      // update_time
      //
      MYSQL_TIME update_time_value;
      my_bool update_time_null;

      // verify_status
      //
      int verify_status_value;
      my_bool verify_status_null;

      // applicant
      //
      details::buffer applicant_value;
      unsigned long applicant_size;
      my_bool applicant_null;

      // approver
      //
      details::buffer approver_value;
      unsigned long approver_size;
      my_bool approver_null;

      // modifier
      //
      details::buffer modifier_value;
      unsigned long modifier_size;
      my_bool modifier_null;

      // jump_label
      //
      details::buffer jump_label_value;
      unsigned long jump_label_size;
      my_bool jump_label_null;

      // jump_data
      //
      details::buffer jump_data_value;
      unsigned long jump_data_size;
      my_bool jump_data_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 19UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::onsale_onsalegroup, id_common >:
    public access::object_traits_impl< ::onsale_onsalegroup, id_mysql >
  {
  };

  // onsale_onsalegroup_stat
  //
  template <>
  class access::view_traits_impl< ::onsale_onsalegroup_stat, id_mysql >:
    public access::view_traits< ::onsale_onsalegroup_stat >
  {
    public:
    struct image_type
    {
      // count
      //
      unsigned long long count_value;
      my_bool count_null;

      // max_id
      //
      unsigned int max_id_value;
      my_bool max_id_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns;

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 2UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  template <>
  class access::view_traits_impl< ::onsale_onsalegroup_stat, id_common >:
    public access::view_traits_impl< ::onsale_onsalegroup_stat, id_mysql >
  {
  };

  // onsale_warelabel
  //
  // onsale_warelabel_stat
  //
  struct access::view_traits_impl< ::onsale_warelabel_stat, id_mysql >::query_columns:
    odb::pointer_query_columns<
      ::onsale_warelabel,
      id_mysql,
      odb::access::object_traits_impl< ::onsale_warelabel, id_mysql > >
  {
  };

  // onsale_warelabelwares
  //
  // onsale_warelabelwares_stat
  //
  struct access::view_traits_impl< ::onsale_warelabelwares_stat, id_mysql >::query_columns:
    odb::pointer_query_columns<
      ::onsale_warelabelwares,
      id_mysql,
      odb::access::object_traits_impl< ::onsale_warelabelwares, id_mysql > >
  {
  };

  // onsale_present
  //
  // onsale_present_stat
  //
  struct access::view_traits_impl< ::onsale_present_stat, id_mysql >::query_columns:
    odb::pointer_query_columns<
      ::onsale_present,
      id_mysql,
      odb::access::object_traits_impl< ::onsale_present, id_mysql > >
  {
  };

  // onsale_step
  //
  // onsale_step_stat
  //
  struct access::view_traits_impl< ::onsale_step_stat, id_mysql >::query_columns:
    odb::pointer_query_columns<
      ::onsale_step,
      id_mysql,
      odb::access::object_traits_impl< ::onsale_step, id_mysql > >
  {
  };

  // onsale_onsalegroup
  //
  // onsale_onsalegroup_stat
  //
  struct access::view_traits_impl< ::onsale_onsalegroup_stat, id_mysql >::query_columns:
    odb::pointer_query_columns<
      ::onsale_onsalegroup,
      id_mysql,
      odb::access::object_traits_impl< ::onsale_onsalegroup, id_mysql > >
  {
  };
}

#include "onsale-odb.ixx"

#include <odb/post.hxx>

#endif // ONSALE_ODB_HXX
